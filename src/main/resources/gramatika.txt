PROGRAM          → FUN_DECL* EOF ;

FUN_DECL         → AT_TYPE IDENT LPAREN PARAM_LIST RPAREN BLOCK
                 | battle LPAREN RPAREN BLOCK ;

AT_TYPE          → '@' TYPE '@' ;

TYPE             → brojElixira
                 | slovoKartice
                 | doubleElixir
                 | imeKartice
                 | bezElixira ;

PARAM_LIST       → ( PARAM ( COMMA PARAM )* )? ;
PARAM            → TYPE IDENT ;

BLOCK            → BLOCK_START STMT* BLOCK_END ;

STMT             → VAR_DECL
                 | ASSIGN_STMT
                 | ARRAY_ASSIGN
                 | IF_STMT
                 | FOR_STMT
                 | FUNC_CALL STMT_END
                 | RETURN_STMT
                 | NEWLINE ;

VAR_DECL         → TYPE IDENT STMT_END
                 | TYPE IDENT ASSIGN EXPR STMT_END
                 | TYPE IDENT LBRACKET TYPE RBRACKET IDENT STMT_END ;

ARRAY_ASSIGN     → IDENT LBRACKET EXPR RBRACKET ASSIGN EXPR STMT_END ;

ASSIGN_STMT      → IDENT ASSIGN EXPR STMT_END ;

RETURN_STMT      → krajBorbe EXPR? STMT_END ;

FUNC_CALL        → IDENT LPAREN ARG_LIST RPAREN ;
ARG_LIST         → ( EXPR ( COMMA EXPR )* )? ;

IF_STMT          → leader LPAREN EXPR RPAREN BLOCK
                   ( elder LPAREN EXPR RPAREN BLOCK )*
                   ( member BLOCK )? ;

FOR_STMT         → cycle LPAREN ASSIGN_STMT EXPR STMT_END ASSIGN_STMT RPAREN BLOCK ;

EXPR             → TERNARY ;

TERNARY          → LOGICAL_OR
                   ( LBRACE_TERNARY EXPR TERNARY_QMARK EXPR TERNARY_COLON EXPR RBRACE_TERNARY )? ;

LOGICAL_OR       → LOGICAL_AND ( LOG_OR LOGICAL_AND )* ;
LOGICAL_AND      → EQUALITY ( LOG_AND EQUALITY )* ;

EQUALITY         → COMPARISON ( ( EQ | NEQ ) COMPARISON )* ;
COMPARISON       → TERM ( ( LT | LE | GT | GE ) TERM )* ;

TERM             → FACTOR ( ( ADD | SUB ) FACTOR )* ;
FACTOR           → UNARY ( ( MULTIPLY | DIVIDE | PERCENT ) UNARY )* ;

UNARY            → ( ADD | SUB | LOG_NOT )? PRIMARY ;

PRIMARY          → INT_LIT
                 | HEX_LIT
                 | OCT_LIT
                 | STRING_LIT
                 | CHAR_LIT
                 | FUNC_CALL
                 | AT_TYPE
                 | IDENT
                 | LPAREN EXPR RPAREN ;

STRING_LIT       → QUOTE ( ANY_CHAR )* QUOTE ;
CHAR_LIT         → APOSTROPHE ANY_CHAR APOSTROPHE ;

STMT_END         → SEMICOLON ;
